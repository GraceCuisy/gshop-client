### 关于json数据
    1.json数据的结构
      结构：类型和标识名称
      值（value）
    2.结构本身是不会显示在页面上，值是可以显示在页面上的
      显示数据时：根据结构读取数据值进行显示

### 在listContent中使用swiper影响了floor组件的轮播
    1.原因
      listContainer中的代码new Swiper('.swiper-container',{}) 这些js代码是在编译后执行的，
      这个选择器最终在选择的时候，是在整个页面中进行选择，
      而在整个页面中有三个div有这个相同的类名，类选择器会匹配上页面中的所有此类名的元素，
      就会都进行配置项的轮播配置，都产生效果
    2.解决办法
      使用vue的ref技术来定义swiper的根元素
      Swiper（）第一个参数既可以传选择器，也可以传具体的元素this.$refs.swiper
    3.不管在哪个组件引入了swiper的css样式文件之后，影响的都是全局的效果
      所以应该把swiper的样式引入放在main.js的文件中，更规范，把影响全局的东西放在main.js中来实现
    4.如果想把引入swiper的代码也放到main.js中
      需要在main.js中引入之后把Swiper挂载到原型对象上，让所有组件都可见
    5.同一个东西，在多个位置引入，只会打包一次，不会打包多次
###  new Swiper('.swiper-container',{}) 执行的时机问题
    1.swiper使用中要求new Swiper需要在页面加载完成后再执行，进行配置
    2.
      1).情况一：直接放在mounted回调函数中执行，发送ajax，请求banners数据的操作是异步的，
        而mounted是同步的，很早执行，所以不可以
      2).情况二： 只利用watch监视banners的数据变化，也不可以，
        代码执行的顺序： 
        ajax请求得到数据 => 数据发生变化 => 执行watch的回调函数 => 界面自动**异步**更新
        所以也不能保证在页面加载完成后执行new Swiper()
      3).情况三：生命周期钩子函数updated，vue官方不推荐，很少用 
        因为界面有一点变化，它就会调用
        推荐使用vm.$nextTick 它能等界面整体都更新完成之后调用
      4).情况四： watch+ vm.$nextTick（callback） 可以实现效果
        vm.$nextTick（callback） 官方描述：将回调延迟到下次 DOM 更新循环之后执行。
        在修改数据之后立即使用它，然后等待 DOM 更新。
        通俗说： 这个方法的回调函数会等到界面异步更新之后才执行，
        但是这个函数有个条件：要求在数据修改之后立即调用这个方法，
        所以这个方法通常放在watch的回调函数中使用
### floor轮播显示的bug问题
    1.现象:
      抽取轮播组件使用之后,floor中的<Carousel/>轮播组件在mounted中已经有数据了,
      数据一直没有变化,不会调用watch中的监视数据的回调函数,所以不会执行new Swiper(),
      不会配置轮播图,所以floor中轮播图显示有问题
    2.分析
      1).总共写了三个<Carousel/>标签,所以最终会产生三个Carousel实例对象,
      他们在挂载到页面上时,都会执行各自的mounted方法,所以mounted方法执行了三次
      2).为什么floor中的Carousel组件开始时就有数据
        home中v-for遍历开始无法执行,因为数据长度为0,所以没有产生Floor组件,更不可能产生Carousel组件
        只有异步请求数据floors回来之后,才会在home组件中自动重新调用v-for,渲染产生两个<Floor/>组件,
        Floor组件产生之后,才会去渲染<Carousel/>组件,此时Carousel组件在floor.carouselList中已经拿到数据了
    3.解决办法
      使用watch监视的handle+immediate版本,设置immediate:true,
      此时就会在Carousel组件初始显示时就立即执行一次数据的监视回调,
      注意:要设置判断 if(数据的长度===0) return 避免让banner中数据长度为零时也执行一次回调new Swiper,
      能使new Swiper的个数和轮播的个数对应上 当前轮播图的数据为零时,没必要配置当前轮播
    4.相关知识点
      1).关于数据绑定的理解:
        开始时data中没有数据=>界面没有显示=>通过发送ajax请求得到数据后=>data中的数据发生了变化
        =>由于数据绑定的存在=>vue会自动重新去渲染界面
      2).vue中的指令都有数据绑定的效果 以v-for为例
        开始时data中没有数据=>v-for遍历的数据为空=>不会产生对应的组件(没有成功遍历)=>
        界面没有显示=>通过发送ajax请求得到数据后=>data中的数据发生了变化=>
        由于数据绑定的存在=>vue会自动重新调用v-for遍历产生组件并渲染到界面上
      3). watch: {
            d: {
              handler: function (val, oldVal) { /* ... */ },
              immediate: true
          },
        immediate为true:组件在初始显示时就会立即执行一次数据对应的回调函数,
        数据发生变化之后还会执行
        immediate默认值为false,只有数据发生改变之后才会执行数据对应的回调函数